Обобщенные структуры
====================================================================

Обобщенная структура
--------------------------

Основной абстракцией, определяющей процедурно-параметрическое обобщение, является обобщенная структура. Она является расширением структуры языка программирования C, а ее синтаксис сформирован таким образом, чтобы не вносить изменения в обычную структур, а осуществить только ее расширение. При этом обычные структуры сохраняются, используясь как ранее. По сути в синтаксис структуры вносится дополнение, которое и определяет формирование обобщение.
::

  обощенная_структура = структура [ обобщающая_часть ]
  обобщающая_часть = ["const"] "<" [ варианты ] ">"
  варианты = помеченные_варианты | непомеченные_варианты | "typedef"
  непомеченные_варианты = ид_типа { "," ид_типа}
  помеченные_варианты = вариант { "," вариант }
  вариант = [признак ":" { признак ":" } ид_типа ]

Вариант ``typedef`` используется в том случае, когда в обобщающей части отстутствуют альтернативы, а расширения в других единицах компиляции должны получить информацию о том, что для альтернатив должны использоваться непомеченные варианты. Если список вариантов пустой, то для последующего расширения используются альтернативы с признаками (помеченные варианты).

Примеры описания обобщенных структур
----------------------------------------

Неизменяемое процедурно-параметрическое обобщение
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Для создания неизменяемого ППО или обобщннной структуры достаточно задать квалификатор ``const`` перед обобщающей частью. В этом случае все дальнейшие расширения будут запрещены независимо от способа задания вариантов. Например, описание дней недели может выглядеть следующим образом:
::

  // Имитация перечислимого типа
  struct week_days {} const
    <Sunday:Monday:Tuesday:Wednesday:Thursday:Friday:Saturday: void>;

Данный подход во многом напоминает формирование перечислимых типов данных. Однако, в отличие от него, позволяет использовать и структурные поля, обеспечивая тем самым формирование фиксированного набора альтернатив с дополнительными параметрами. В качестве примера можно рассмотреть обобщенную структуру обеспечивающую разделение людей по признаку пола:
::

  // Обобщенная структура с неизменяемыми специализациями
  struct gender { int ade, height; } const <male: female: void>;

Различие вариантов фиксируется в обобщающей части заданием соответствующего признака специализации. В общей части обобщенной структуры задаются характеристики общие для любого человека. Помимо этого неизменяемое обобщение может быть реализовано и для любых базовых и структурных типов, принимающих различные значения. Это можно рассмотреть на формировании обобщенного понятия числа:
::

  // Обобщение чисел как единого понятия (представлены не все возможные типы)
  struct number {} const <int, unsigned, float, double, long long>;

В данном случе каждый из числовых типов определяет значение, которое он содержит.

Изменяемые обобщенные структуры
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Данный вид обобщений не описывает все возможные альтернативы. Они могут расширяться как в той же, так и других единицах компиляции. Отличием от неизменяемых обобщений является отсутствие квалификатора ``const``.

Наиже рассматриваетсяи обобщающая структура, содержащая в качестве альтернатив прямоугольник и треугольник:

::

  // Прямоугольник
  typedef struct Rectangle { int x, y; } Rectangle;
  // Треугольник
  typedef struct Triangle { int a, b, c; } Triangle;

  // Фигура, обобщающая альтернативные по типу фигуры
  // (без использования описания typedef)
  struct Figure01 {} < struct Rectangle, struct Triangle >;

  // Фигура, обобщающая другие фигуры по признаку,
  // где ромб задается диагоналями (с использованием описания typedef)
  struct Figure02 {} <rect: rhomb: Rectangle, trian: Triangle>;

Как и для любой структуры можно использовать ``typedef``

::

  typedef Figure03 {} <> Figure;

Можно также создавать конструкции, которые содержат структурные поля:
::

  enum Color {red, orange, yellow, green, azure, blue, violet};
  typedef struct ColoredFigure {Color color;}<Rectangle, Triangle> ColoredFigure;

Помимо этого допускается формировать обобщенную структуру путем использования в качестве специализации других обобщенных струкур. Например использование одной такой структуры в качестве специализации может обеспечить формирование фигуры с цветом следующим образом:
::

  struct ColoredFigure2 {Color color;} const <struct Figure01>;

Этот подход удобен, когда последующее расширение обобщение желательно скрыть от клиентской единицы компиляции, которая может использовать только предоставляемые ей специализации.

Расширение обобщенной структуры
------------------------------------

Расширение обобщенной структуры может осуществляться как в текущей, так и в других единицах компиляции. В первом случае компилятор сам может сделать необходимые объединения и сформировать общий код для обобщенной структуры (по аналогии с синтаксически управляемым препроцессингом). Во втором случае объединение возможно на уровне специального компоновщика (что, наверное, не очень удобно из-за появления дополнительных костылей). И в том и другом случае возможно формирование обобщения во время запуска программы как дополнительного процесса, предшествующего запуску функции main. Это требует специального исследования.

С точки зрения синтаксиса расширение обобщенной структуры выглядит как добавление альтернатив к уже существующей структуре, описание которой должно быть известно и представлено, например в заголовочном файле. Возможная проблема может быть связана с тем, что в разных расширениях могут быть одинаковые признаки, что ведет к семантической некорректности, разрешение которой требует отдельных исследований.

В целом синтаксис расширения может выглядеть следующим образом:

::

  расширение_обобщения = обобщающий_тип "+=" обобщающая_часть

Задание альтернатив в обобщающей части должно совпадать с их определением в обобщенной структуре. То есть, при использовании признаков, признаки должны присутствовать и в обобщающей части расширения.

Примеры расширения обобщений
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Добавление круга в обобщенные фигуры может происходить следующим образом:
::

  // Круг
  typedef struct Circle { int r; } Circle;

  // Добавлени круга с использованием разных приемов
  struct Figure01 += <Circle>;
  struct Figure02 += <circ: struct Circle>;
  Figure  += <c: Circle, r: Rectangle, t: Triangle>;

Использование рекурсивных (рекуррентных) определений
----------------------------------------------------------

.. note::

  Необходимо заимстовать и внести материал из других статей и источников, переведя его в синтаксис Си.

Использование обобщенных структур в качестве специализаций в других обобщенных структурах позволяет формировать цепочки специализаций произвольной длины. Подобное возможно в том случае, если предшествующие типы являются также обобщенными структурами. Это позволяет контролировать добавление новых специализаций (уточнений). Например, для формирования новой ступени обобщения ``T`` необходимо включить в него в качестве специализации первого уровня обобщение ``T0``, содержащего свою «точку» для расширения, которую можно подключить к ``T``:
::

  typedef struct T0 {int z;}<> T0;
  typedef struct T {int x, y;}<> T;
  T += <t0: bool>;
  T += <t1: struct {double r; char s;}>;
  T += <t2: T0>;

Тип T0 можно также уточнять, добавляя к нему новые специализации, которые также могут содержать обобщения:
::

  typedef struct T00 {int a;}<> T00;
  T0 += <t00: T00>;

Использование данного приема позволяет выстраивать сложные зависимости между типами, воспринимая при этом различные специализации как уточнения одного и того же типа. Примеры подобных специализаций представлены в разделе, описывающим обобщенные переменные.

Допускается также рекурсивное подключение к существующим обобщениям других обобщений, включая и использования объявляемой обобщенной структуры в качестве ее же специализации. Это позволяет выстраивать длинные статические цепочки, формируемые на этапе компиляции программы. Например, можно добавить следующее расширение обобщения ``T``:
::

  T += <t3: T>;

Варианты рекуррентных специализаций представлены в разделе, описывающем обобщенные переменные.
